<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Dice 2000</title>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      overflow: hidden; 
      background: #000; 
      font-family: 'Courier New', monospace;
    }
    

    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 10;
    }
    
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      color: white;
      font-size: 16px;
      pointer-events: none;
      z-index: 100;
      text-shadow: 0 0 5px #ff3030, 0 0 10px #ff3030;
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #ff3030;
      font-size: 24px;
      font-weight: bold;
      z-index: 1000;
    }
    
    #loading::after {
      content: "DIGITAL REALITY SYSTEM";
      font-size: 14px;
      margin-top: 10px;
      opacity: 0.8;
    }

    @media (max-width: 768px) {
      #instructions {
        font-size: 14px;
        bottom: 10px;
      }
      #loading {
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="loading">NEON DICE 2000</div>
  <div id="instructions">Tap or click anywhere to roll the dice</div>
  
  <script type="module">
    // Import libraries with fallbacks
    const loadScript = (url, fallbackUrl) => {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.type = 'module';
        script.src = url;
        script.onload = resolve;
        script.onerror = () => {
          console.warn(`Failed to load script from ${url}, trying fallback...`);
          if (fallbackUrl) {
            const fallbackScript = document.createElement('script');
            fallbackScript.type = 'module';
            fallbackScript.src = fallbackUrl;
            fallbackScript.onload = resolve;
            fallbackScript.onerror = reject;
            document.head.appendChild(fallbackScript);
          } else {
            reject(new Error(`Failed to load script: ${url}`));
          }
        };
        document.head.appendChild(script);
      });
    };

    // Try to import libraries with fallbacks
    let THREE, RAPIER;
    try {
      THREE = await import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js')
        .catch(() => import('./libs/three.module.js'));
    } catch (error) {
      showError('Failed to load Three.js library. Please check your internet connection or refresh the page.');
      throw error;
    }

    try {
      RAPIER = await import('https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.15.0/rapier.es.js')
        .catch(() => import('./libs/rapier.es.js'));
    } catch (error) {
      showError('Failed to load Rapier physics engine. Please check your internet connection or refresh the page.');
      throw error;
    }

    // Error display function
    function showError(message) {
      const loadingEl = document.getElementById('loading');
      loadingEl.innerHTML = `Error: ${message}`;
      loadingEl.style.color = '#ff0000';
    }

    // Create a neon text texture function
    function createNeonTextTexture(text, color, glowColor, size = 512) {
      const canvas = document.createElement('canvas');
      canvas.width = size * 4; // Wide for text
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      
      // Background
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Text settings
      const fontSize = size / 2.5;
      ctx.font = `bold ${fontSize}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Glow effect - multiple layers with decreasing blur and opacity
      for (let i = 10; i > 0; i--) {
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = i * 6;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.fillStyle = `rgba(${parseInt(glowColor.slice(1, 3), 16)}, ${parseInt(glowColor.slice(3, 5), 16)}, ${parseInt(glowColor.slice(5, 7), 16)}, ${0.2 + (10-i) * 0.05})`;
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      }
      
      // Core text
      ctx.shadowBlur = 0;
      ctx.fillStyle = color;
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      
      // Inner tube highlight - simulating the inner light tube
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.font = `bold ${fontSize * 0.97}px Arial, sans-serif`;
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      
      return new THREE.CanvasTexture(canvas);
    }
    
    // Create a Tron-style grid texture
    function createTronGridTexture(color1 = '#00ffff', color2 = '#0066ff', size = 1024) {
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      
      // Background
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, size, size);
      
      // Major grid lines
      const majorSpacing = size / 10;
      ctx.lineWidth = 3;
      
      // Draw major grid lines with glow
      for (let i = 0; i <= 10; i++) {
        const pos = i * majorSpacing;
        
        // Horizontal lines
        ctx.strokeStyle = color1;
        ctx.shadowColor = color1;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, pos);
        ctx.lineTo(size, pos);
        ctx.stroke();
        
        // Vertical lines
        ctx.strokeStyle = color2;
        ctx.shadowColor = color2;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, size);
        ctx.stroke();
      }
      
      // Minor grid lines (thinner, less glow)
      ctx.lineWidth = 1;
      ctx.shadowBlur = 4;
      const minorSpacing = majorSpacing / 5;
      
      for (let i = 0; i <= 50; i++) {
        const pos = i * minorSpacing;
        
        // Only draw minor lines that aren't on top of major lines
        if (i % 5 !== 0) {
          // Horizontal minor lines
          ctx.strokeStyle = color1;
          ctx.shadowColor = color1;
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.moveTo(0, pos);
          ctx.lineTo(size, pos);
          ctx.stroke();
          
          // Vertical minor lines
          ctx.strokeStyle = color2;
          ctx.shadowColor = color2;
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.moveTo(pos, 0);
          ctx.lineTo(pos, size);
          ctx.stroke();
        }
      }
      
      // Reset
      ctx.globalAlpha = 1.0;
      ctx.shadowBlur = 0;
      
      return new THREE.CanvasTexture(canvas);
    }
    
    // Main application
    async function initApp() {
      try {
        // Initialize Rapier physics engine
        await RAPIER.init();
        document.getElementById('loading').style.display = 'none';
        
        // Create scene
        const scene = new THREE.Scene();
        
        // Setup camera with closer position
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(3, 8, 15);
        camera.lookAt(0, 0, 0);
        
        // Setup renderer with proper pixel ratio for sharp rendering
        const renderer = new THREE.WebGLRenderer({ 
          antialias: true,
          alpha: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor(0x000000, 0);
        document.body.appendChild(renderer.domElement);
        
        // Setup physics world
        const gravity = { x: 0, y: -9.81, z: 0 };
        const world = new RAPIER.World(gravity);
        
        // Adjust floor size to accommodate the more powerful throw
        const floorBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, 0, 0);
        const floorBody = world.createRigidBody(floorBodyDesc);
        const floorColliderDesc = RAPIER.ColliderDesc.cuboid(80, 0.1, 80); // much larger half extents
        world.createCollider(floorColliderDesc, floorBody);
        
        // Function to create dice face texture
        function createDiceFaceTexture(value, neonColor) {
          try {
            const canvas = document.createElement('canvas');
            canvas.width = 512; // Higher resolution for better quality
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            if (!ctx) {
              throw new Error("Failed to get canvas context");
            }
            
            // Fill background black
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Setup neon effect
            const hexColor = '#' + neonColor.toString(16).padStart(6, '0');
            ctx.shadowColor = hexColor;
            ctx.shadowBlur = 30;
            
            const pipRadius = 35;
            const center = 256;
            const offset = 128;
            
            ctx.fillStyle = 'white';
            
            function drawPip(x, y) {
              ctx.beginPath();
              ctx.arc(x, y, pipRadius, 0, Math.PI * 2);
              ctx.fill();
            }
            
            switch(value) {
              case 1:
                drawPip(center, center);
                break;
              case 2:
                drawPip(center + offset, center - offset);
                drawPip(center - offset, center + offset);
                break;
              case 3:
                drawPip(center - offset, center - offset);
                drawPip(center, center);
                drawPip(center + offset, center + offset);
                break;
              case 4:
                drawPip(center - offset, center - offset);
                drawPip(center + offset, center - offset);
                drawPip(center - offset, center + offset);
                drawPip(center + offset, center + offset);
                break;
              case 5:
                drawPip(center - offset, center - offset);
                drawPip(center + offset, center - offset);
                drawPip(center, center);
                drawPip(center - offset, center + offset);
                drawPip(center + offset, center + offset);
                break;
              case 6:
                drawPip(center - offset, center - offset);
                drawPip(center - offset, center);
                drawPip(center - offset, center + offset);
                drawPip(center + offset, center - offset);
                drawPip(center + offset, center);
                drawPip(center + offset, center + offset);
                break;
            }
            
            return new THREE.CanvasTexture(canvas);
          } catch (error) {
            console.error("Error creating dice face texture:", error);
            // Return a simple fallback texture
            const fallbackCanvas = document.createElement('canvas');
            fallbackCanvas.width = 128;
            fallbackCanvas.height = 128;
            const ctx = fallbackCanvas.getContext('2d');
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = '#' + neonColor.toString(16).padStart(6, '0');
            ctx.font = 'bold 64px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(value.toString(), 64, 64);
            return new THREE.CanvasTexture(fallbackCanvas);
          }
        }
        
        // Function to create a dice
        function createDice(neonColor) {
          try {
            const size = 1.5;
            
            // Define face numbers (standard dice configuration)
            const faceNumbers = [1, 6, 2, 5, 3, 4]; // right, left, top, bottom, front, back
            
            const materials = faceNumbers.map(num => {
              const texture = createDiceFaceTexture(num, neonColor);
              texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
              
              return new THREE.MeshStandardMaterial({
                color: 0x000000,
                emissive: neonColor,
                emissiveMap: texture,
                emissiveIntensity: 1,
                roughness: 0.3,
                metalness: 0.7
              });
            });
            
            // Create dice mesh
            const geometry = new THREE.BoxGeometry(size, size, size);
            const diceMesh = new THREE.Mesh(geometry, materials);
            diceMesh.castShadow = true;
            scene.add(diceMesh);
            
            // Add wireframe for edges
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ 
              color: neonColor,
              linewidth: 2
            });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            diceMesh.add(wireframe);
            
            // Create physics body - using a single cuboid collider for stability
            const diceBodyDesc = RAPIER.RigidBodyDesc.dynamic()
              .setTranslation(Math.random() * 2 - 1, 5, Math.random() * 2 - 1);
            
            const diceBody = world.createRigidBody(diceBodyDesc);
            
            // Use a single cuboid collider for more stable physics
            const boxColliderDesc = RAPIER.ColliderDesc.cuboid(size/2, size/2, size/2)
              .setRestitution(0.3) // Bounciness
              .setFriction(0.8);   // Friction
            
            world.createCollider(boxColliderDesc, diceBody);
            
            // Set damping for more realistic movement
            diceBody.setLinearDamping(0.5);
            diceBody.setAngularDamping(0.5);
            
            return { mesh: diceMesh, body: diceBody };
          } catch (error) {
            console.error("Error creating dice:", error);
            showError("Failed to create dice. Please refresh the page.");
            throw error;
          }
        }
        
        // Create dice with neon colors
        const dice1 = createDice(0xff00ff); // Pink
        const dice2 = createDice(0x00ffff); // Cyan
        
        // Create point lights for dice glow
        const pinkLight = new THREE.PointLight(0xff00ff, 2, 10);
        pinkLight.position.set(0, 5, 0);
        scene.add(pinkLight);
        
        const cyanLight = new THREE.PointLight(0x00ffff, 2, 10);
        cyanLight.position.set(0, 5, 0);
        scene.add(cyanLight);
        
        // Create mountain material with shader
        const mountainMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            color: { value: new THREE.Color(0x00ffff) }
          },
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vPosition;
            varying vec3 vNormal;
            varying vec3 vViewDir;
            
            void main() {
              vUv = uv;
              vPosition = position;
              vNormal = normalize(normalMatrix * normal);
              vec4 worldPosition = modelMatrix * vec4(position, 1.0);
              vViewDir = normalize(cameraPosition - worldPosition.xyz);
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            varying vec2 vUv;
            varying vec3 vPosition;
            varying vec3 vNormal;
            varying vec3 vViewDir;
            
            // Noise function for texture
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) {
              const vec2 C = vec2(1.0/6.0, 1.0/3.0);
              const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
              
              vec3 i  = floor(v + dot(v, C.yyy));
              vec3 x0 = v - i + dot(i, C.xxx);
              
              vec3 g = step(x0.yzx, x0.xyz);
              vec3 l = 1.0 - g;
              vec3 i1 = min(g.xyz, l.zxy);
              vec3 i2 = max(g.xyz, l.zxy);
              
              vec3 x1 = x0 - i1 + C.xxx;
              vec3 x2 = x0 - i2 + C.yyy;
              vec3 x3 = x0 - D.yyy;
              
              i = mod289(i);
              vec4 p = permute(permute(permute(
                i.z + vec4(0.0, i1.z, i2.z, 1.0))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                
              float n_ = 0.142857142857;
              vec3 ns = n_ * D.wyz - D.xzx;
              
              vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
              
              vec4 x_ = floor(j * ns.z);
              vec4 y_ = floor(j - 7.0 * x_);
              
              vec4 x = x_ * ns.x + ns.yyyy;
              vec4 y = y_ * ns.x + ns.yyyy;
              vec4 h = 1.0 - abs(x) - abs(y);
              
              vec4 b0 = vec4(x.xy, y.xy);
              vec4 b1 = vec4(x.zw, y.zw);
              
              vec4 s0 = floor(b0)*2.0 + 1.0;
              vec4 s1 = floor(b1)*2.0 + 1.0;
              vec4 sh = -step(h, vec4(0.0));
              
              vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
              vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
              
              vec3 p0 = vec3(a0.xy, h.x);
              vec3 p1 = vec3(a0.zw, h.y);
              vec3 p2 = vec3(a1.xy, h.z);
              vec3 p3 = vec3(a1.zw, h.w);
              
              vec4 norm0 = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
              p0 *= norm0.x;
              p1 *= norm0.y;
              p2 *= norm0.z;
              p3 *= norm0.w;
              
              vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
              m = m * m;
              m = m * m;
              
              return 42.0 * dot(m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
            
            void main() {
              // Create static grid pattern
              float gridSize = 20.0;
              vec2 grid = abs(fract(vUv * gridSize) - 0.5);
              float line = min(grid.x, grid.y);
              
              // Create sharp, neon-like grid lines
              float glow = 1.0 - smoothstep(0.0, 0.05, line);
              
              // Calculate reflection
              vec3 reflection = reflect(-vViewDir, vNormal);
              float reflectionIntensity = pow(max(dot(reflection, vViewDir), 0.0), 32.0);
              
              // Create obsidian-like base color with texture
              vec3 obsidianColor = vec3(0.1, 0.1, 0.15);
              
              // Add subtle texture variation
              float noise = snoise(vPosition * 2.0) * 0.1;
              obsidianColor += vec3(noise);
              
              // Add reflection highlights with texture influence
              vec3 finalColor = obsidianColor + vec3(reflectionIntensity * 0.5);
              
              // Add grid glow with texture influence
              finalColor += color * glow * (0.3 + noise * 0.2);
              
              // Add subtle ambient glow
              finalColor += vec3(0.05, 0.05, 0.05);
              
              gl_FragColor = vec4(finalColor, 1.0);
            }
          `,
          side: THREE.DoubleSide
        });
        
        // Create mountain geometry
        const mountainGeometry = new THREE.PlaneGeometry(40, 40, 50, 50);
        const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
        mountain.rotation.x = -Math.PI / 2;
        mountain.position.y = -0.1;
        scene.add(mountain);
        
        // Function to roll the dice
        function rollDice() {
          try {
            // Set starting positions from the bottom right corner
            const height = 5;  // Higher starting position
            
            // Position dice at the bottom right corner of the visible area
            dice1.body.setTranslation(new RAPIER.Vector3(10, height, 10), true);
            dice2.body.setTranslation(new RAPIER.Vector3(10.5, height, 9), true);
            
            // Reset velocities
            dice1.body.setLinvel(new RAPIER.Vector3(0, 0, 0), true);
            dice1.body.setAngvel(new RAPIER.Vector3(0, 0, 0), true);
            dice2.body.setLinvel(new RAPIER.Vector3(0, 0, 0), true);
            dice2.body.setAngvel(new RAPIER.Vector3(0, 0, 0), true);
            
            // Apply a much stronger toss toward the center
            const baseImpulseX = -20 - Math.random() * 4; // Stronger force toward left
            const baseImpulseZ = -20 - Math.random() * 4; // Stronger force toward back
            const upwardForce = 8 + Math.random() * 2;    // Much higher upward toss
            
            // First die - with stronger forces for dramatic effect
            dice1.body.applyImpulse(
              new RAPIER.Vector3(baseImpulseX, upwardForce, baseImpulseZ), 
              true
            );
            dice1.body.applyTorqueImpulse(
              new RAPIER.Vector3((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6),
              true
            );
            
            // Second die - small variation from the first
            dice2.body.applyImpulse(
              new RAPIER.Vector3(baseImpulseX * 0.9, upwardForce * 1.1, baseImpulseZ * 1.1),
              true
            );
            dice2.body.applyTorqueImpulse(
              new RAPIER.Vector3((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6),
              true
            );
          } catch (error) {
            console.error("Error rolling dice:", error);
          }
        }
        
        // Add click/touch event listener
        renderer.domElement.addEventListener('click', rollDice);
        renderer.domElement.addEventListener('touchstart', (e) => {
          e.preventDefault(); // Prevent default touch behavior
          rollDice();
        });
        
        // Initial roll
        setTimeout(rollDice, 500);
        
        // Create render target for snapshot
        const snapshotSize = 256;
        const snapshotRenderTarget = new THREE.WebGLRenderTarget(snapshotSize, snapshotSize);
        
        // Create top-down camera for snapshot
        const snapshotCamera = new THREE.OrthographicCamera(
          -10, 10,  // left, right
          10, -10,  // top, bottom
          1, 1000   // near, far
        );
        snapshotCamera.position.set(0, 20, 0);
        snapshotCamera.lookAt(0, 0, 0);
        snapshotCamera.up.set(0, 0, -1);
        
        // Create snapshot container
        const snapshotContainer = document.createElement('div');
        snapshotContainer.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: rgba(0, 0, 0, 0.8);
          border: 2px solid #00ffff;
          border-radius: 4px;
          padding: 10px;
          display: none;
          z-index: 1000;
          box-shadow: 0 0 10px #00ffff;
        `;
        
        // Create snapshot canvas
        const snapshotCanvas = document.createElement('canvas');
        snapshotCanvas.width = snapshotSize;
        snapshotCanvas.height = snapshotSize;
        snapshotContainer.appendChild(snapshotCanvas);
        
        // Create throw counter
        const throwCounter = document.createElement('div');
        throwCounter.style.cssText = `
          color: #00ffff;
          font-family: 'Courier New', monospace;
          font-size: 14px;
          text-align: center;
          margin: 5px 0;
          text-shadow: 0 0 5px #00ffff;
        `;
        throwCounter.textContent = 'Throws: 0';
        snapshotContainer.appendChild(throwCounter);
        
        // Create throw again button
        const throwButton = document.createElement('button');
        throwButton.style.cssText = `
          background: transparent;
          border: 1px solid #00ffff;
          color: #00ffff;
          padding: 8px 16px;
          font-family: 'Courier New', monospace;
          font-size: 14px;
          cursor: pointer;
          width: 100%;
          transition: all 0.3s ease;
          text-shadow: 0 0 5px #00ffff;
          box-shadow: 0 0 5px #00ffff;
        `;
        throwButton.textContent = 'THROW AGAIN';
        throwButton.onmouseover = () => {
          throwButton.style.background = 'rgba(0, 255, 255, 0.1)';
          throwButton.style.boxShadow = '0 0 10px #00ffff';
        };
        throwButton.onmouseout = () => {
          throwButton.style.background = 'transparent';
          throwButton.style.boxShadow = '0 0 5px #00ffff';
        };
        snapshotContainer.appendChild(throwButton);
        
        document.body.appendChild(snapshotContainer);
        
        // Add throw counter variable
        let throwCount = 0;
        
        // Function to check if dice have stopped moving
        function checkDiceStopped() {
          const velocityThreshold = 0.1;
          const angularVelocityThreshold = 0.1;
          
          const dice1Stopped = 
            dice1.body.linvel().length < velocityThreshold &&
            dice1.body.angvel().length < angularVelocityThreshold;
            
          const dice2Stopped = 
            dice2.body.linvel().length < velocityThreshold &&
            dice2.body.angvel().length < angularVelocityThreshold;
            
          return dice1Stopped && dice2Stopped;
        }
        
        // Function to take snapshot
        function takeSnapshot() {
          // Store current render target
          const currentRenderTarget = renderer.getRenderTarget();
          
          // Render to snapshot target
          renderer.setRenderTarget(snapshotRenderTarget);
          renderer.render(scene, snapshotCamera);
          
          // Read pixels from render target
          const buffer = new Uint8Array(snapshotSize * snapshotSize * 4);
          renderer.readRenderTargetPixels(
            snapshotRenderTarget,
            0, 0,
            snapshotSize, snapshotSize,
            buffer
          );
          
          // Create image data
          const ctx = snapshotCanvas.getContext('2d');
          const imageData = ctx.createImageData(snapshotSize, snapshotSize);
          imageData.data.set(buffer);
          
          // Draw to canvas
          ctx.putImageData(imageData, 0, 0);
          
          // Restore original render target
          renderer.setRenderTarget(currentRenderTarget);
          
          // Show snapshot container
          snapshotContainer.style.display = 'block';
        }
        
        // Modify rollDice function
        const originalRollDice = rollDice;
        rollDice = function() {
          throwCount++;
          throwCounter.textContent = `Throws: ${throwCount}`;
          snapshotContainer.style.display = 'none';
          originalRollDice();
        };
        
        // Add throw button click handler
        throwButton.addEventListener('click', rollDice);
        
        // Animation frame ID for proper cleanup
        let animationFrameId;
        let diceStoppedTimeout;
        
        // Animation loop
        function animate() {
          animationFrameId = requestAnimationFrame(animate);
          
          // Step the physics world
          world.step();
          
          // Update dice positions from physics
          [dice1, dice2].forEach(dice => {
            const pos = dice.body.translation();
            dice.mesh.position.set(pos.x, pos.y, pos.z);
            
            const rot = dice.body.rotation();
            dice.mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
          });
          
          // Move point lights with dice for enhanced visual effect
          pinkLight.position.copy(dice1.mesh.position);
          pinkLight.position.y += 3;
          
          cyanLight.position.copy(dice2.mesh.position);
          cyanLight.position.y += 3;
          
          // Update mountain animation
          mountainMaterial.uniforms.time.value += 0.005;
          
          // Check if dice have stopped
          if (checkDiceStopped()) {
            if (!diceStoppedTimeout) {
              diceStoppedTimeout = setTimeout(() => {
                takeSnapshot();
              }, 1000); // Wait 1 second after dice stop
            }
          } else {
            if (diceStoppedTimeout) {
              clearTimeout(diceStoppedTimeout);
              diceStoppedTimeout = null;
            }
          }
          
          renderer.render(scene, camera);
        }
        
        animate();
        
        // Pause animation when tab is not visible to save resources
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            cancelAnimationFrame(animationFrameId);
          } else {
            animate();
          }
        });
        
        // Handle window resizing with proper event debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          }, 250);
        });
        
      } catch (error) {
        console.error('Failed to initialize application:', error);
        showError('Failed to initialize application. Please check your internet connection or refresh the page.');
      }
    }
    
    // Start the application
    initApp();
  </script>
</body>
</html>