<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Dice 2000</title>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      overflow: hidden; 
      background: #000; 
      font-family: 'Courier New', monospace;
    }
    

    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 10;
    }
    
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      color: white;
      font-size: 16px;
      pointer-events: none;
      z-index: 100;
      text-shadow: 0 0 5px #ff3030, 0 0 10px #ff3030;
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #ff3030;
      font-size: 24px;
      font-weight: bold;
      z-index: 1000;
    }
    
    #loading::after {
      content: "DIGITAL REALITY SYSTEM";
      font-size: 14px;
      margin-top: 10px;
      opacity: 0.8;
    }

    @media (max-width: 768px) {
      #instructions {
        font-size: 14px;
        bottom: 10px;
      }
      #loading {
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="loading">NEON DICE 2000</div>
  <div id="instructions">Tap or click anywhere to roll the dice</div>
  
  <script type="module">
    // Import libraries with fallbacks
    const loadScript = (url, fallbackUrl) => {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.type = 'module';
        script.src = url;
        script.onload = resolve;
        script.onerror = () => {
          console.warn(`Failed to load script from ${url}, trying fallback...`);
          if (fallbackUrl) {
            const fallbackScript = document.createElement('script');
            fallbackScript.type = 'module';
            fallbackScript.src = fallbackUrl;
            fallbackScript.onload = resolve;
            fallbackScript.onerror = reject;
            document.head.appendChild(fallbackScript);
          } else {
            reject(new Error(`Failed to load script: ${url}`));
          }
        };
        document.head.appendChild(script);
      });
    };

    // Try to import libraries with fallbacks
    let THREE, RAPIER;
    try {
      THREE = await import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js')
        .catch(() => import('./libs/three.module.js'));
    } catch (error) {
      showError('Failed to load Three.js library. Please check your internet connection or refresh the page.');
      throw error;
    }

    try {
      RAPIER = await import('https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.15.0/rapier.es.js')
        .catch(() => import('./libs/rapier.es.js'));
    } catch (error) {
      showError('Failed to load Rapier physics engine. Please check your internet connection or refresh the page.');
      throw error;
    }

    // Error display function
    function showError(message) {
      const loadingEl = document.getElementById('loading');
      loadingEl.innerHTML = `Error: ${message}`;
      loadingEl.style.color = '#ff0000';
    }

    // Create a neon text texture function
    function createNeonTextTexture(text, color, glowColor, size = 512) {
      const canvas = document.createElement('canvas');
      canvas.width = size * 4; // Wide for text
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      
      // Background
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Text settings
      const fontSize = size / 2.5;
      ctx.font = `bold ${fontSize}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Glow effect - multiple layers with decreasing blur and opacity
      for (let i = 10; i > 0; i--) {
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = i * 6;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.fillStyle = `rgba(${parseInt(glowColor.slice(1, 3), 16)}, ${parseInt(glowColor.slice(3, 5), 16)}, ${parseInt(glowColor.slice(5, 7), 16)}, ${0.2 + (10-i) * 0.05})`;
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      }
      
      // Core text
      ctx.shadowBlur = 0;
      ctx.fillStyle = color;
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      
      // Inner tube highlight - simulating the inner light tube
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.font = `bold ${fontSize * 0.97}px Arial, sans-serif`;
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      
      return new THREE.CanvasTexture(canvas);
    }
    
    // Create a Tron-style grid texture
    function createTronGridTexture(color1 = '#00ffff', color2 = '#0066ff', size = 1024) {
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      
      // Background
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, size, size);
      
      // Major grid lines
      const majorSpacing = size / 10;
      ctx.lineWidth = 3;
      
      // Draw major grid lines with glow
      for (let i = 0; i <= 10; i++) {
        const pos = i * majorSpacing;
        
        // Horizontal lines
        ctx.strokeStyle = color1;
        ctx.shadowColor = color1;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, pos);
        ctx.lineTo(size, pos);
        ctx.stroke();
        
        // Vertical lines
        ctx.strokeStyle = color2;
        ctx.shadowColor = color2;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, size);
        ctx.stroke();
      }
      
      // Minor grid lines (thinner, less glow)
      ctx.lineWidth = 1;
      ctx.shadowBlur = 4;
      const minorSpacing = majorSpacing / 5;
      
      for (let i = 0; i <= 50; i++) {
        const pos = i * minorSpacing;
        
        // Only draw minor lines that aren't on top of major lines
        if (i % 5 !== 0) {
          // Horizontal minor lines
          ctx.strokeStyle = color1;
          ctx.shadowColor = color1;
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.moveTo(0, pos);
          ctx.lineTo(size, pos);
          ctx.stroke();
          
          // Vertical minor lines
          ctx.strokeStyle = color2;
          ctx.shadowColor = color2;
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.moveTo(pos, 0);
          ctx.lineTo(pos, size);
          ctx.stroke();
        }
      }
      
      // Reset
      ctx.globalAlpha = 1.0;
      ctx.shadowBlur = 0;
      
      return new THREE.CanvasTexture(canvas);
    }
    
    // Main application
    async function initApp() {
      try {
        // Initialize Rapier physics engine
        await RAPIER.init();
        document.getElementById('loading').style.display = 'none';
        
        // Create scene
        const scene = new THREE.Scene();
        
        // Setup camera with closer position
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(3, 8, 15);
        camera.lookAt(0, 0, 0);
        
        // Setup renderer with proper pixel ratio for sharp rendering
        const renderer = new THREE.WebGLRenderer({ 
          antialias: true,
          alpha: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor(0x000000, 0); // Transparent background
        document.body.appendChild(renderer.domElement);
        
        // Add ambient and directional lights
        const ambientLight = new THREE.AmbientLight(0x000033, 0.4); // Blue-tinted ambient for futuristic feel
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Add point lights for neon glow effect
        const pinkLight = new THREE.PointLight(0xff00ff, 3, 20);
        pinkLight.position.set(5, 5, 5);
        scene.add(pinkLight);
        
        const cyanLight = new THREE.PointLight(0x00ffff, 3, 20);
        cyanLight.position.set(-5, 5, -5);
        scene.add(cyanLight);
        
        // Add blue light for digital aesthetic
        const blueLight = new THREE.PointLight(0x3030ff, 2, 100);
        blueLight.position.set(0, 30, -40);
        scene.add(blueLight);
        
        // Setup physics world
        const gravity = { x: 0, y: -9.81, z: 0 };
        const world = new RAPIER.World(gravity);
        
        // Adjust floor size to accommodate the more powerful throw
        const floorBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, 0, 0);
        const floorBody = world.createRigidBody(floorBodyDesc);
        const floorColliderDesc = RAPIER.ColliderDesc.cuboid(80, 0.1, 80); // much larger half extents
        world.createCollider(floorColliderDesc, floorBody);
        
        // Function to create a Tron-style grid texture
        const gridSize = 2048;
        const gridCanvas = document.createElement('canvas');
        gridCanvas.width = gridSize;
        gridCanvas.height = gridSize;
        const gridCtx = gridCanvas.getContext('2d');
        
        // Background
        gridCtx.fillStyle = 'black';
        gridCtx.fillRect(0, 0, gridSize, gridSize);
        
        // Major grid lines
        const majorSpacing = gridSize / 10;
        gridCtx.lineWidth = 3;
        
        // Draw major grid lines with glow
        for (let i = 0; i <= 10; i++) {
          const pos = i * majorSpacing;
          
          // Horizontal lines
          gridCtx.strokeStyle = '#00ffff';
          gridCtx.shadowColor = '#00ffff';
          gridCtx.shadowBlur = 10;
          gridCtx.beginPath();
          gridCtx.moveTo(0, pos);
          gridCtx.lineTo(gridSize, pos);
          gridCtx.stroke();
          
          // Vertical lines
          gridCtx.strokeStyle = '#0066ff';
          gridCtx.shadowColor = '#0066ff';
          gridCtx.shadowBlur = 10;
          gridCtx.beginPath();
          gridCtx.moveTo(pos, 0);
          gridCtx.lineTo(pos, gridSize);
          gridCtx.stroke();
        }
        
        // Minor grid lines (thinner, less glow)
        gridCtx.lineWidth = 1;
        gridCtx.shadowBlur = 4;
        const minorSpacing = majorSpacing / 5;
        
        for (let i = 0; i <= 50; i++) {
          const pos = i * minorSpacing;
          
          // Only draw minor lines that aren't on top of major lines
          if (i % 5 !== 0) {
            // Horizontal minor lines
            gridCtx.strokeStyle = '#00ffff';
            gridCtx.shadowColor = '#00ffff';
            gridCtx.globalAlpha = 0.5;
            gridCtx.beginPath();
            gridCtx.moveTo(0, pos);
            gridCtx.lineTo(gridSize, pos);
            gridCtx.stroke();
            
            // Vertical minor lines
            gridCtx.strokeStyle = '#0066ff';
            gridCtx.shadowColor = '#0066ff';
            gridCtx.globalAlpha = 0.5;
            gridCtx.beginPath();
            gridCtx.moveTo(pos, 0);
            gridCtx.lineTo(pos, gridSize);
            gridCtx.stroke();
          }
        }
        
        // Reset
        gridCtx.globalAlpha = 1.0;
        gridCtx.shadowBlur = 0;
        
        const gridTexture = new THREE.CanvasTexture(gridCanvas);
        gridTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        
        // Floor mesh with Tron grid texture
        const floorGeometry = new THREE.PlaneGeometry(160, 160);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
          map: gridTexture,
          emissive: 0x000033, // Subtle blue glow
          emissiveMap: gridTexture,
          emissiveIntensity: 0.4,
          side: THREE.DoubleSide,
          roughness: 0.3,
          metalness: 0.9,
          transparent: true,
          opacity: 0.9 // More visible floor
        });
        const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);
        
        // Create TRON-style mountain terrain with volume
        const mountainWidth = 160;
        const mountainDepth = 80;
        const segments = 30; // More segments for sharper edges
        const mountainGeometry = new THREE.PlaneGeometry(
          mountainWidth,
          mountainDepth,
          segments,
          segments / 2
        );
        
        // Create dramatic mountain peaks and valleys
        const vertices = mountainGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
          const x = vertices[i];
          const z = vertices[i + 2];
          
          // Create sharp, angular peaks with multiple layers
          const distance = Math.abs(x / mountainWidth);
          const baseHeight = 30; // Base height for all mountains
          
          // Multiple sine waves for more complex terrain
          const peak1 = Math.abs(Math.sin(x * 0.3) * 25);
          const peak2 = Math.abs(Math.cos(z * 0.4) * 20);
          const peak3 = Math.abs(Math.sin((x + z) * 0.2) * 15);
          
          // Combine peaks with different weights
          const combinedPeak = (peak1 * 0.5 + peak2 * 0.3 + peak3 * 0.2);
          
          // Add sharp edges by rounding to nearest multiple
          const sharpness = 5;
          const sharpPeak = Math.round(combinedPeak / sharpness) * sharpness;
          
          // Apply height with distance falloff and minimum height
          vertices[i + 1] = Math.max(sharpPeak * (1 - distance * 0.7), baseHeight * (1 - distance));
        }
        
        mountainGeometry.computeVertexNormals();
        
        // Create wireframe material with enhanced glow effect
        const mountainMaterial = new THREE.ShaderMaterial({
          uniforms: {
            color: { value: new THREE.Color(0x00ffff) },
            glowColor: { value: new THREE.Color(0x00ffff) },
            time: { value: 0 }
          },
          vertexShader: `
            varying vec3 vPosition;
            varying vec3 vNormal;
            void main() {
              vPosition = position;
              vNormal = normal;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            uniform vec3 glowColor;
            uniform float time;
            varying vec3 vPosition;
            varying vec3 vNormal;
            
            void main() {
              float intensity = mod(vPosition.y * 0.15 + time * 0.3, 1.0);
              float normalIntensity = abs(dot(vNormal, vec3(0.0, 1.0, 0.0)));
              vec3 finalColor = mix(color, glowColor, intensity * 0.7 + normalIntensity * 0.3);
              gl_FragColor = vec4(finalColor, 0.9);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide,
          wireframe: true,
          wireframeLinewidth: 1
        });
        
        const mountainMesh = new THREE.Mesh(mountainGeometry, mountainMaterial);
        mountainMesh.position.set(0, 0, -mountainDepth);
        mountainMesh.rotation.x = -Math.PI / 4; // Steeper angle
        scene.add(mountainMesh);
        
        // Add solid black material behind wireframe for depth
        const mountainSolidMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.95
        });
        
        const mountainSolidMesh = new THREE.Mesh(mountainGeometry, mountainSolidMaterial);
        mountainSolidMesh.position.copy(mountainMesh.position);
        mountainSolidMesh.rotation.copy(mountainMesh.rotation);
        scene.add(mountainSolidMesh);
        
        // Update mountain animation in the animate loop
        const originalAnimate = animate;
        animate = function() {
          mountainMaterial.uniforms.time.value += 0.005; // Slower animation
          originalAnimate();
        }
        
        // Function to create dice face texture
        function createDiceFaceTexture(value, neonColor) {
          try {
            const canvas = document.createElement('canvas');
            canvas.width = 512; // Higher resolution for better quality
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            if (!ctx) {
              throw new Error("Failed to get canvas context");
            }
            
            // Fill background black
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Setup neon effect
            const hexColor = '#' + neonColor.toString(16).padStart(6, '0');
            ctx.shadowColor = hexColor;
            ctx.shadowBlur = 30;
            
            const pipRadius = 35;
            const center = 256;
            const offset = 128;
            
            ctx.fillStyle = 'white';
            
            function drawPip(x, y) {
              ctx.beginPath();
              ctx.arc(x, y, pipRadius, 0, Math.PI * 2);
              ctx.fill();
            }
            
            switch(value) {
              case 1:
                drawPip(center, center);
                break;
              case 2:
                drawPip(center + offset, center - offset);
                drawPip(center - offset, center + offset);
                break;
              case 3:
                drawPip(center - offset, center - offset);
                drawPip(center, center);
                drawPip(center + offset, center + offset);
                break;
              case 4:
                drawPip(center - offset, center - offset);
                drawPip(center + offset, center - offset);
                drawPip(center - offset, center + offset);
                drawPip(center + offset, center + offset);
                break;
              case 5:
                drawPip(center - offset, center - offset);
                drawPip(center + offset, center - offset);
                drawPip(center, center);
                drawPip(center - offset, center + offset);
                drawPip(center + offset, center + offset);
                break;
              case 6:
                drawPip(center - offset, center - offset);
                drawPip(center - offset, center);
                drawPip(center - offset, center + offset);
                drawPip(center + offset, center - offset);
                drawPip(center + offset, center);
                drawPip(center + offset, center + offset);
                break;
            }
            
            return new THREE.CanvasTexture(canvas);
          } catch (error) {
            console.error("Error creating dice face texture:", error);
            // Return a simple fallback texture
            const fallbackCanvas = document.createElement('canvas');
            fallbackCanvas.width = 128;
            fallbackCanvas.height = 128;
            const ctx = fallbackCanvas.getContext('2d');
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = '#' + neonColor.toString(16).padStart(6, '0');
            ctx.font = 'bold 64px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(value.toString(), 64, 64);
            return new THREE.CanvasTexture(fallbackCanvas);
          }
        }
        
        // Function to create a dice
        function createDice(neonColor) {
          try {
            const size = 1.5;
            
            // Define face numbers (standard dice configuration)
            const faceNumbers = [1, 6, 2, 5, 3, 4]; // right, left, top, bottom, front, back
            
            const materials = faceNumbers.map(num => {
              const texture = createDiceFaceTexture(num, neonColor);
              texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
              
              return new THREE.MeshStandardMaterial({
                color: 0x000000,
                emissive: neonColor,
                emissiveMap: texture,
                emissiveIntensity: 1,
                roughness: 0.3,
                metalness: 0.7
              });
            });
            
            // Create dice mesh
            const geometry = new THREE.BoxGeometry(size, size, size);
            const diceMesh = new THREE.Mesh(geometry, materials);
            diceMesh.castShadow = true;
            scene.add(diceMesh);
            
            // Add wireframe for edges
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ 
              color: neonColor,
              linewidth: 2
            });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            diceMesh.add(wireframe);
            
            // Create physics body - using a single cuboid collider for stability
            const diceBodyDesc = RAPIER.RigidBodyDesc.dynamic()
              .setTranslation(Math.random() * 2 - 1, 5, Math.random() * 2 - 1);
            
            const diceBody = world.createRigidBody(diceBodyDesc);
            
            // Use a single cuboid collider for more stable physics
            const boxColliderDesc = RAPIER.ColliderDesc.cuboid(size/2, size/2, size/2)
              .setRestitution(0.3) // Bounciness
              .setFriction(0.8);   // Friction
            
            world.createCollider(boxColliderDesc, diceBody);
            
            // Set damping for more realistic movement
            diceBody.setLinearDamping(0.5);
            diceBody.setAngularDamping(0.5);
            
            return { mesh: diceMesh, body: diceBody };
          } catch (error) {
            console.error("Error creating dice:", error);
            showError("Failed to create dice. Please refresh the page.");
            throw error;
          }
        }
        
        // Create dice with neon colors
        const dice1 = createDice(0xff00ff); // Pink
        const dice2 = createDice(0x00ffff); // Cyan
        
        // Function to roll the dice
        function rollDice() {
          try {
            // Set starting positions from the bottom right corner
            const height = 5;  // Higher starting position
            
            // Position dice at the bottom right corner of the visible area
            dice1.body.setTranslation(new RAPIER.Vector3(10, height, 10), true);
            dice2.body.setTranslation(new RAPIER.Vector3(10.5, height, 9), true);
            
            // Reset velocities
            dice1.body.setLinvel(new RAPIER.Vector3(0, 0, 0), true);
            dice1.body.setAngvel(new RAPIER.Vector3(0, 0, 0), true);
            dice2.body.setLinvel(new RAPIER.Vector3(0, 0, 0), true);
            dice2.body.setAngvel(new RAPIER.Vector3(0, 0, 0), true);
            
            // Apply a much stronger toss toward the center
            const baseImpulseX = -20 - Math.random() * 4; // Stronger force toward left
            const baseImpulseZ = -20 - Math.random() * 4; // Stronger force toward back
            const upwardForce = 8 + Math.random() * 2;    // Much higher upward toss
            
            // First die - with stronger forces for dramatic effect
            dice1.body.applyImpulse(
              new RAPIER.Vector3(baseImpulseX, upwardForce, baseImpulseZ), 
              true
            );
            dice1.body.applyTorqueImpulse(
              new RAPIER.Vector3((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6),
              true
            );
            
            // Second die - small variation from the first
            dice2.body.applyImpulse(
              new RAPIER.Vector3(baseImpulseX * 0.9, upwardForce * 1.1, baseImpulseZ * 1.1),
              true
            );
            dice2.body.applyTorqueImpulse(
              new RAPIER.Vector3((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6),
              true
            );
          } catch (error) {
            console.error("Error rolling dice:", error);
          }
        }
        
        // Add click/touch event listener
        renderer.domElement.addEventListener('click', rollDice);
        renderer.domElement.addEventListener('touchstart', (e) => {
          e.preventDefault(); // Prevent default touch behavior
          rollDice();
        });
        
        // Initial roll
        setTimeout(rollDice, 500);
        
        // Animation frame ID for proper cleanup
        let animationFrameId;
        
        // Animation loop
        function animate() {
          animationFrameId = requestAnimationFrame(animate);
          
          // Step the physics world
          world.step();
          
          // Update dice positions from physics
          [dice1, dice2].forEach(dice => {
            const pos = dice.body.translation();
            dice.mesh.position.set(pos.x, pos.y, pos.z);
            
            const rot = dice.body.rotation();
            dice.mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
          });
          
          // Move point lights with dice for enhanced visual effect
          pinkLight.position.copy(dice1.mesh.position);
          pinkLight.position.y += 3;
          
          cyanLight.position.copy(dice2.mesh.position);
          cyanLight.position.y += 3;
          
          renderer.render(scene, camera);
        }
        
        animate();
        
        // Pause animation when tab is not visible to save resources
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            cancelAnimationFrame(animationFrameId);
          } else {
            animate();
          }
        });
        
        // Handle window resizing with proper event debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          }, 250);
        });
        
      } catch (error) {
        console.error('Failed to initialize application:', error);
        showError('Failed to initialize application. Please check your internet connection or refresh the page.');
      }
    }
    
    // Start the application
    initApp();
  </script>
</body>
</html>