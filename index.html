<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Neon Dice Game with Akira Cityscape</title>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      overflow: hidden; 
      background: #000; 
      font-family: 'Courier New', monospace;
    }
    
    #ascii-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -10;
      color: rgba(255, 50, 50, 0.2); /* Red tint for Akira's Neo-Tokyo */
      font-size: 6px;
      line-height: 6px;
      white-space: pre;
      overflow: hidden;
      pointer-events: none;
      font-family: 'Courier New', monospace;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 10;
    }
    
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      color: white;
      font-size: 16px;
      pointer-events: none;
      z-index: 100;
      text-shadow: 0 0 5px #ff3030, 0 0 10px #ff3030; /* Red glow like Akira */
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #ff3030;
      font-size: 24px;
      font-weight: bold;
      z-index: 1000;
    }
    
    #loading::after {
      content: "NEO-TOKYO 2019";
      font-size: 14px;
      margin-top: 10px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div id="loading">AKIRA DICE SYSTEM</div>
  <div id="ascii-background"></div>
  <div id="instructions">Click anywhere to roll the dice</div>
  
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import RAPIER from 'https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.11.2/rapier.es.js';

    // Create Akira-style Neo-Tokyo cityscape
    function generateAkiraCityscape() {
      // Get dimensions
      const container = document.getElementById('ascii-background');
      if (!container) return;
      
      // Character width and height
      const charWidth = 6;
      const charHeight = 6;
      
      // Calculate dimensions
      const width = Math.ceil(window.innerWidth / charWidth);
      const height = Math.ceil(window.innerHeight / charHeight);
      
      // Character sets for Akira-style cityscape
      const buildingChars = ['█', '▓', '▒', '░', '■', '□', '▪', '◼', '◾', '⬛'];
      const windowChars = ['◯', '○', '◎', '●', '◌', '☼'];
      const towerChars = ['|', '¦', '┃', '║', '│', '❘', '❙', '❚'];
      const neonSignChars = ['卍', '中', '東', '京', '新', '田', '渋', '谷', '池', '袋', '港', '区', '大', '阪', '梅', '神', '戸', '高', '札', '幌', '街', '都'];
      const pipeChars = ['═', '━', '─', '╍', '╌', '┅', '┄', '┉', '┈', '╱', '╲'];
      const craneChars = ['┌', '┐', '┘', '└', '╔', '╗', '╝', '╚', '╓', '╖', '╜', '╙', '╒', '╕', '╛', '╘'];
      
      let asciiArt = '';
      
      // Create a complex skyline with many buildings
      const skylineProfile = [];
      
      // First generate a basic skyline shape
      for (let x = 0; x < width; x++) {
        const distFromCenter = Math.abs(x - width/2) / (width/2);
        
        // Base height - Neo-Tokyo has a dense skyline with varying heights
        let baseHeight = Math.floor(height * (0.6 - 0.2 * distFromCenter));
        
        // Add more randomness for cyberpunk feel
        const randomHeight = Math.floor(Math.random() * (height * 0.3));
        let buildingHeight = baseHeight + randomHeight;
        
        // Add occasional super-tall towers (like the iconic Olympic stadium)
        if (Math.random() < 0.03) {
          buildingHeight = Math.floor(height * 0.85);
        }
        
        skylineProfile.push(buildingHeight);
      }
      
      // Add the iconic Olympic stadium/tower in the center
      const centerX = Math.floor(width / 2);
      const olympicStadiumWidth = Math.floor(width * 0.1);
      const olympicStadiumHeight = Math.floor(height * 0.9);
      
      for (let x = centerX - Math.floor(olympicStadiumWidth/2); x < centerX + Math.floor(olympicStadiumWidth/2); x++) {
        if (x >= 0 && x < width) {
          skylineProfile[x] = olympicStadiumHeight;
        }
      }
      
      // Add towers and spires
      for (let x = 0; x < width; x++) {
        if (Math.random() < 0.05 && x % 5 === 0) {
          const towerHeight = Math.floor(height * (0.7 + Math.random() * 0.2));
          skylineProfile[x] = towerHeight;
        }
      }
      
      // Generate the cityscape row by row
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const buildingHeight = skylineProfile[x];
          const yFromBottom = height - y;
          
          // Special handling for Olympic stadium/tower in the center
          const isInOlympicStadium = Math.abs(x - centerX) < Math.floor(olympicStadiumWidth/2) && 
                                   yFromBottom < olympicStadiumHeight;
          
          if (yFromBottom <= buildingHeight) {
            // Inside a building
            if (isInOlympicStadium) {
              // Olympic stadium/central tower
              if (x === centerX && yFromBottom > olympicStadiumHeight - 10) {
                // Top antenna of stadium
                asciiArt += '|';
              } else if (Math.abs(x - centerX) < 2 && yFromBottom > olympicStadiumHeight - 15) {
                // Olympic tower
                asciiArt += towerChars[Math.floor(Math.random() * towerChars.length)];
              } else if (Math.random() < 0.3) {
                // Windows and structural elements of the stadium
                asciiArt += windowChars[Math.floor(Math.random() * windowChars.length)];
              } else {
                // Stadium structure
                asciiArt += buildingChars[Math.floor(Math.random() * 3)]; // Dense structure
              }
            } else {
              // Normal buildings
              
              // Determine if this is a building edge
              const isLeftEdge = x === 0 || skylineProfile[x-1] < yFromBottom;
              const isRightEdge = x === width-1 || skylineProfile[x+1] < yFromBottom;
              const isTop = yFromBottom === buildingHeight;
              
              if (isTop) {
                // Building top
                if (Math.random() < 0.3) {
                  // Rooftop antenna or crane
                  asciiArt += craneChars[Math.floor(Math.random() * craneChars.length)];
                } else {
                  asciiArt += '▀';
                }
              } else if (isLeftEdge || isRightEdge) {
                // Building edge
                asciiArt += '|';
              } else if (yFromBottom % 2 === 0 && Math.random() < 0.3) {
                // Windows and lights
                if (Math.random() < 0.05) {
                  // Neon signs - more common in Neo-Tokyo
                  asciiArt += neonSignChars[Math.floor(Math.random() * neonSignChars.length)];
                } else {
                  asciiArt += windowChars[Math.floor(Math.random() * windowChars.length)];
                }
              } else if (yFromBottom % 3 === 0 && Math.random() < 0.2) {
                // Horizontal pipes and structures
                asciiArt += pipeChars[Math.floor(Math.random() * pipeChars.length)];
              } else {
                // Building structure
                asciiArt += buildingChars[Math.floor(Math.random() * buildingChars.length)];
              }
            }
          } else {
            // Sky
            if (Math.random() < 0.01) {
              // Light aircraft or stars
              asciiArt += '.';
            } else {
              // Empty sky
              asciiArt += ' ';
            }
          }
        }
        asciiArt += '\n';
      }
      
      // Apply to container
      container.innerHTML = asciiArt;
    }
    
    // Main application
    async function initApp() {
      try {
        // Initialize Rapier physics engine
        await RAPIER.init();
        document.getElementById('loading').style.display = 'none';
        
        // Create scene
        const scene = new THREE.Scene();
        
        // Setup camera with closer position
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(3, 8, 15);
        camera.lookAt(0, 0, 0);
        
        // Setup renderer with proper pixel ratio for sharp rendering
        const renderer = new THREE.WebGLRenderer({ 
          antialias: true,
          alpha: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor(0x000000, 0); // Transparent background
        document.body.appendChild(renderer.domElement);
        
        // Add ambient and directional lights
        const ambientLight = new THREE.AmbientLight(0x330000, 0.4); // Red-tinted ambient for Akira feel
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Add point lights for neon glow effect
        const pinkLight = new THREE.PointLight(0xff00ff, 3, 20);
        pinkLight.position.set(5, 5, 5);
        scene.add(pinkLight);
        
        const cyanLight = new THREE.PointLight(0x00ffff, 3, 20);
        cyanLight.position.set(-5, 5, -5);
        scene.add(cyanLight);
        
        // Add red light for Akira aesthetic
        const redLight = new THREE.PointLight(0xff3030, 2, 100);
        redLight.position.set(0, 30, -40);
        scene.add(redLight);
        
        // Setup physics world
        const gravity = { x: 0, y: -9.81, z: 0 };
        const world = new RAPIER.World(gravity);
        
        // Adjust floor size to accommodate the more powerful throw
        const floorBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, 0, 0);
        const floorBody = world.createRigidBody(floorBodyDesc);
        const floorColliderDesc = RAPIER.ColliderDesc.cuboid(80, 0.1, 80); // much larger half extents
        world.createCollider(floorColliderDesc, floorBody);
        
        // Floor mesh - matching the larger physics floor but with Akira-inspired design
        const floorGeometry = new THREE.PlaneGeometry(160, 160);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x110000, // Dark red tint
          side: THREE.DoubleSide,
          roughness: 0.5,
          metalness: 0.8,
          transparent: true,
          opacity: 0.4 // More transparent to see background
        });
        const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);
        
        // Add grid lines to floor for cyber feel
        const gridHelper = new THREE.GridHelper(160, 40, 0xff3030, 0x330000);
        gridHelper.position.y = 0.01; // Slightly above floor
        scene.add(gridHelper);
        
        // Function to create dice face texture
        function createDiceFaceTexture(value, neonColor) {
          const canvas = document.createElement('canvas');
          canvas.width = 512; // Higher resolution for better quality
          canvas.height = 512;
          const ctx = canvas.getContext('2d');
          
          // Fill background black
          ctx.fillStyle = '#000000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Setup neon effect
          const hexColor = '#' + neonColor.toString(16).padStart(6, '0');
          ctx.shadowColor = hexColor;
          ctx.shadowBlur = 30;
          
          const pipRadius = 35;
          const center = 256;
          const offset = 128;
          
          ctx.fillStyle = 'white';
          
          function drawPip(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, pipRadius, 0, Math.PI * 2);
            ctx.fill();
          }
          
          switch(value) {
            case 1:
              drawPip(center, center);
              break;
            case 2:
              drawPip(center + offset, center - offset);
              drawPip(center - offset, center + offset);
              break;
            case 3:
              drawPip(center - offset, center - offset);
              drawPip(center, center);
              drawPip(center + offset, center + offset);
              break;
            case 4:
              drawPip(center - offset, center - offset);
              drawPip(center + offset, center - offset);
              drawPip(center - offset, center + offset);
              drawPip(center + offset, center + offset);
              break;
            case 5:
              drawPip(center - offset, center - offset);
              drawPip(center + offset, center - offset);
              drawPip(center, center);
              drawPip(center - offset, center + offset);
              drawPip(center + offset, center + offset);
              break;
            case 6:
              drawPip(center - offset, center - offset);
              drawPip(center - offset, center);
              drawPip(center - offset, center + offset);
              drawPip(center + offset, center - offset);
              drawPip(center + offset, center);
              drawPip(center + offset, center + offset);
              break;
          }
          
          return new THREE.CanvasTexture(canvas);
        }
        
        // Function to create a dice
        function createDice(neonColor) {
          const size = 1.5;
          
          // Define face numbers (standard dice configuration)
          const faceNumbers = [1, 6, 2, 5, 3, 4]; // right, left, top, bottom, front, back
          
          const materials = faceNumbers.map(num => {
            const texture = createDiceFaceTexture(num, neonColor);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            
            return new THREE.MeshStandardMaterial({
              color: 0x000000,
              emissive: neonColor,
              emissiveMap: texture,
              emissiveIntensity: 1,
              roughness: 0.3,
              metalness: 0.7
            });
          });
          
          // Create dice mesh
          const geometry = new THREE.BoxGeometry(size, size, size);
          const diceMesh = new THREE.Mesh(geometry, materials);
          diceMesh.castShadow = true;
          scene.add(diceMesh);
          
          // Add wireframe for edges
          const edges = new THREE.EdgesGeometry(geometry);
          const lineMaterial = new THREE.LineBasicMaterial({ 
            color: neonColor,
            linewidth: 2
          });
          const wireframe = new THREE.LineSegments(edges, lineMaterial);
          diceMesh.add(wireframe);
          
          // Create physics body - using a single cuboid collider for stability
          const diceBodyDesc = RAPIER.RigidBodyDesc.dynamic()
            .setTranslation(Math.random() * 2 - 1, 5, Math.random() * 2 - 1);
          
          const diceBody = world.createRigidBody(diceBodyDesc);
          
          // Use a single cuboid collider for more stable physics
          const boxColliderDesc = RAPIER.ColliderDesc.cuboid(size/2, size/2, size/2)
            .setRestitution(0.3) // Bounciness
            .setFriction(0.8);   // Friction
          
          world.createCollider(boxColliderDesc, diceBody);
          
          // Set damping for more realistic movement
          diceBody.setLinearDamping(0.5);
          diceBody.setAngularDamping(0.5);
          
          return { mesh: diceMesh, body: diceBody };
        }
        
        // Create dice with neon colors
        const dice1 = createDice(0xff00ff); // Pink
        const dice2 = createDice(0x00ffff); // Cyan
        
        // Function to roll the dice - keeping your settings
        function rollDice() {
          // Set starting positions from the bottom right corner
          const height = 5;  // Higher starting position - your setting
          
          // Position dice at the bottom right corner of the visible area
          dice1.body.setTranslation(new RAPIER.Vector3(10, height, 10), true);
          dice2.body.setTranslation(new RAPIER.Vector3(10.5, height, 9), true);
          
          // Reset velocities
          dice1.body.setLinvel(new RAPIER.Vector3(0, 0, 0), true);
          dice1.body.setAngvel(new RAPIER.Vector3(0, 0, 0), true);
          dice2.body.setLinvel(new RAPIER.Vector3(0, 0, 0), true);
          dice2.body.setAngvel(new RAPIER.Vector3(0, 0, 0), true);
          
          // Apply a much stronger toss toward the center - your settings
          const baseImpulseX = -20 - Math.random() * 4; // Stronger force toward left
          const baseImpulseZ = -20 - Math.random() * 4; // Stronger force toward back
          const upwardForce = 8 + Math.random() * 2;    // Much higher upward toss
          
          // First die - with stronger forces for dramatic effect - your settings
          dice1.body.applyImpulse(
            new RAPIER.Vector3(baseImpulseX, upwardForce, baseImpulseZ), 
            true
          );
          dice1.body.applyTorqueImpulse(
            new RAPIER.Vector3((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6),
            true
          );
          
          // Second die - small variation from the first
          dice2.body.applyImpulse(
            new RAPIER.Vector3(baseImpulseX * 0.9, upwardForce * 1.1, baseImpulseZ * 1.1),
            true
          );
          dice2.body.applyTorqueImpulse(
            new RAPIER.Vector3((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6),
            true
          );
        }
        
        // Add click event listener
        renderer.domElement.addEventListener('click', rollDice);
        
        // Initial roll
        setTimeout(rollDice, 500);
        
        // Animation loop
        function animate() {
          requestAnimationFrame(animate);
          
          // Step the physics world
          world.step();
          
          // Update dice positions from physics
          [dice1, dice2].forEach(dice => {
            const pos = dice.body.translation();
            dice.mesh.position.set(pos.x, pos.y, pos.z);
            
            const rot = dice.body.rotation();
            dice.mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
          });
          
          // Move point lights with dice for enhanced visual effect
          pinkLight.position.copy(dice1.mesh.position);
          pinkLight.position.y += 3;
          
          cyanLight.position.copy(dice2.mesh.position);
          cyanLight.position.y += 3;
          
          renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle window resizing
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          generateAkiraCityscape(); // Regenerate ASCII art on resize
        });
        
        // Generate the initial ASCII cityscape
        generateAkiraCityscape();
        
      } catch (error) {
        console.error('Failed to initialize application:', error);
        document.getElementById('loading').innerHTML = 'Error loading physics engine. Please check the console.';
      }
    }
    
    // Start the application
    initApp();
  </script>
</body>
</html>